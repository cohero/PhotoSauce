<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#
procDef[] ta = {
	new procDef {
		name = "4Chan",
		channels = 4,
		colors = 4,
		xUnroll = 4,
		yUnroll = 2
	},
	new procDef {
		name = "3Chan",
		channels = 3,
		colors = 3,
		xUnroll = 3,
		yUnroll = 0
	},
	new procDef {
		name = "1Chan",
		channels = 1,
		colors = 1,
		xUnroll = 4,
		yUnroll = 2
	}
};
#>
//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

#if HWINTRINSICS
using System;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using System.Runtime.CompilerServices;

using VectorAvx = System.Runtime.Intrinsics.Vector256<float>;
using VectorSse = System.Runtime.Intrinsics.Vector128<float>;

namespace PhotoSauce.MagicScaler.Transforms
{
<#
foreach (var t in ta) {
	if (t != ta[0]) WriteLine(null);
#>
	internal sealed partial class Convolver<#= t.name #>Intrinsic : IConvolver
	{
		private const uint channels = <#= t.channels #>;

		public static readonly Convolver<#= t.name #>Intrinsic Instance = new Convolver<#= t.name #>Intrinsic();

		private Convolver<#= t.name #>Intrinsic() { }

		int IConvolver.Channels => (int)channels;
		int IConvolver.MapChannels => (int)channels;

		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + (nuint)cb);
			uint* pmapx = (uint*)mapxstart;
			nuint kstride = (nuint)smapx * channels;
			nuint tstride = (nuint)smapy * <#= t.channels == 3 ? "4" /* 3Chan to 3XChan x-over */ : "channels" #>;
			nuint vcnt = kstride / (nuint)VectorSse.Count;

			while (tp < tpe)
			{
				nuint ix = *pmapx++;
				nuint lcnt = vcnt;

				float* ip = (float*)istart + ix * channels;
				float* mp = (float*)(mapxstart + *pmapx++);

				VectorSse av0<# for (int i = 1; t.channels == 3 && i < t.colors; i++) { #>, av<#= i #><# } #>;

				if (Avx.IsSupported && lcnt >= <#= (t.channels == 3 ? 3 : 1) * 2 #>)
				{
<#
for (int i = 0; i < (t.channels == 3 ? 3 : 1); i++) {
#>
					var ax<#= i #> = VectorAvx.Zero;
<#
}

for (int unroll = t.xUnroll; unroll > 0; unroll -= (t.channels == 3 ? 3 : 1)) {
	if (unroll == t.xUnroll) {
#>

					for (; lcnt >= <#= unroll * 2 #>; lcnt -= <#= unroll * 2 #>)
					{
<#
	} else {
#>
					<#= unroll < t.xUnroll - 1  ? "else " : "" #>if (lcnt >= <#= unroll * 2 #>)
					{
						lcnt -= <#= unroll * 2 #>;

<#
	}
	for (int i = 0; i < unroll; i++) {
#>
						var iv<#= i #> = Avx.LoadVector256(ip<#= i != 0 ? $" + VectorAvx.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						ip += VectorAvx.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						ax<#= t.channels == 3 ? i : 0 #> = HWIntrinsics.MultiplyAdd(ax<#= t.channels == 3 ? i : 0 #>, iv<#= i #>, mp<#= i != 0 ? $" + VectorAvx.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						mp += VectorAvx.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;
					}
<#
	if (unroll == t.xUnroll || unroll == 1) WriteLine(null);
}

if (t.channels == 3) {
#>
					av0 = Sse.Add(ax0.GetLower(), ax1.GetUpper());
					av1 = Sse.Add(ax0.GetUpper(), ax2.GetLower());
					av2 = Sse.Add(ax1.GetLower(), ax2.GetUpper());
<#
} else {
#>
					av0 = Sse.Add(ax0.GetLower(), ax0.GetUpper());
<#
}
#>
				}
				else
				{
					av0<# for (int i = 1; t.channels == 3 && i < t.colors; i++) { #> = av<#= i #><# } #> = VectorSse.Zero;
<#
for (int unroll = t.xUnroll; t.channels != 3 && unroll > 0; unroll -= 2) {
	if (unroll == t.xUnroll) {
#>

					for (; lcnt >= <#= unroll #>; lcnt -= <#= unroll #>)
					{
<#
	} else {
#>
					<#= unroll < t.xUnroll - 2  ? "else " : "" #>if (lcnt >= <#= unroll #>)
					{
						lcnt -= <#= unroll #>;

<#
	}
	for (int i = 0; i < unroll; i++) {
#>
						var iv<#= i #> = Sse.LoadVector128(ip<#= i != 0 ? $" + VectorSse.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						ip += VectorSse.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						av<#= t.channels == 3 ? i : 0 #> = HWIntrinsics.MultiplyAdd(av<#= t.channels == 3 ? i : 0 #>, iv<#= i #>, mp<#= i != 0 ? $" + VectorSse.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						mp += VectorSse.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;
					}
<#
	if (unroll == t.xUnroll || unroll == 1) WriteLine(null);
}
#>
				}

<#
int cxunroll = t.channels == 3 ? 3 : 1;
if (t.channels == 3) {
#>
				for (; lcnt != 0; lcnt -= <#= cxunroll #>)
				{
<#
} else {
#>
				if (lcnt != 0)
				{
<#
}
for (int i = 0; i < cxunroll; i++) {
#>
					var iv<#= i #> = Sse.LoadVector128(ip<#= i != 0 ? $" + VectorSse.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
if (t.channels == 3) {
#>
					ip += VectorSse.Count<#= cxunroll > 1 ? $" * {cxunroll}" : "" #>;
<#
}
WriteLine(null);
for (int i = 0; i < cxunroll; i++) {
#>
					av<#= t.channels == 3 ? i : 0 #> = HWIntrinsics.MultiplyAdd(av<#= t.channels == 3 ? i : 0 #>, iv<#= i #>, mp<#= i != 0 ? $" + VectorSse.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
if (t.channels == 3) {
#>
					mp += VectorSse.Count<#= cxunroll > 1 ? $" * {cxunroll}" : "" #>;
<#
}
#>
				}

<#
if (t.channels == 1) {
#>
				*tp = av0.HorizontalAdd();
<#
} else {
	if (t.channels == 3) {
#>
				var avs = Sse.Add(Sse.Add(
					Sse.Shuffle(av0, av0, 0b_00_10_01_11),
					Sse.Shuffle(av1, av1, 0b_00_01_11_10)),
					Sse.Shuffle(av2, av2, 0b_00_11_10_01)
				);

				av0 = Sse.MoveLowToHigh(Sse.UnpackLow(av0, av1), av2);
				av0 = Sse.Add(av0, avs);

<#
	}
#>
				Sse.Store(tp, av0);
<#
}
#>
				tp += tstride;
			}
		}

<#
if (t.yUnroll > 0) {
#>
		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			nuint tstride = (nuint)smapy * channels;
			nuint vcnt = tstride / (nuint)VectorSse.Count, nox = (nuint)ox;

			for (nuint xc = nox + (nuint)ow; nox < xc; nox++)
			{
				nuint lcnt = vcnt;

				float* tp = (float*)tstart + nox * tstride;
				float* mp = (float*)pmapy;

				VectorSse av0<# for (int i = 1; t.channels == 3 && i < t.colors; i++) { #>, av<#= i #><# } #>;

				if (Avx.IsSupported && lcnt >= <#= (t.channels == 3 ? 3 : 1) * 2 #>)
				{
<#
for (int i = 0; i < (t.channels == 3 ? 3 : 1); i++) {
#>
					var ax<#= i #> = VectorAvx.Zero;
<#
}

for (int unroll = t.yUnroll; unroll > 0; unroll -= (t.channels == 3 ? 3 : 1)) {
	if (unroll == t.yUnroll) {
#>

					for (; lcnt >= <#= unroll * 2 #>; lcnt -= <#= unroll * 2 #>)
					{
<#
	} else {
#>
					if (lcnt >= <#= unroll * 2 #>)
					{
						lcnt -= <#= unroll * 2 #>;

<#
	}
	for (int i = 0; i < unroll; i++) {
#>
						var iv<#= i #> = Avx.LoadVector256(tp<#= i != 0 ? $" + VectorAvx.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						tp += VectorAvx.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						ax<#= t.channels == 3 ? i : 0 #> = HWIntrinsics.MultiplyAdd(ax<#= t.channels == 3 ? i : 0 #>, iv<#= i #>, mp<#= i != 0 ? $" + VectorAvx.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						mp += VectorAvx.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;
					}
<#
	if (unroll == t.yUnroll || unroll == 1) WriteLine(null);
}
#>
					av0 = Sse.Add(ax0.GetLower(), ax0.GetUpper());
				}
				else
				{
					av0<# for (int i = 1; t.channels == 3 && i < t.colors; i++) { #> = av<#= i #><# } #> = VectorSse.Zero;

<#
for (int unroll = t.yUnroll; t.channels != 3 && unroll > 0; unroll -= 2) {
	if (unroll == t.yUnroll) {
#>
					for (; lcnt >= <#= unroll #>; lcnt -= <#= unroll #>)
					{
<#
	} else {
#>
					<#= unroll < t.yUnroll - 2  ? "else " : "" #>if (lcnt >= <#= unroll #>)
					{
						lcnt -= <#= unroll #>;

<#
	}
	for (int i = 0; i < unroll; i++) {
#>
						var iv<#= i #> = Sse.LoadVector128(tp<#= i != 0 ? $" + VectorSse.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						tp += VectorSse.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						av<#= t.channels == 3 ? i : 0 #> = HWIntrinsics.MultiplyAdd(av<#= t.channels == 3 ? i : 0 #>, iv<#= i #>, mp<#= i != 0 ? $" + VectorSse.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						mp += VectorSse.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;
					}
<#
	if (unroll == t.yUnroll && unroll != 2) WriteLine(null);
}
#>
				}

				if (lcnt != 0)
				{
<#
int cyunroll = t.channels == 3 ? 3 : 1;
for (int i = 0; i < cyunroll; i++) {
#>
					var iv<#= i #> = Sse.LoadVector128(tp<#= i != 0 ? $" + VectorSse.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
WriteLine(null);
for (int i = 0; i < cyunroll; i++) {
#>
					av<#= t.channels == 3 ? i : 0 #> = HWIntrinsics.MultiplyAdd(av<#= t.channels == 3 ? i : 0 #>, iv<#= i #>, mp<#= i != 0 ? $" + VectorSse.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
#>
				}

<#
if (t.channels == 1) {
#>
				*op++ = av0.HorizontalAdd();
<#
} else {
#>
				Sse.Store(op, av0);
				op += channels;
<#
}
#>
			}
		}
<#
} else {
#>
		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy) => throw new NotImplementedException();
<#
}
#>

		public override string ToString() => nameof(Convolver<#= t.name #>Intrinsic);
	}

	internal sealed partial class Convolver<#= t.name #>Vector : IVectorConvolver
	{
		IConvolver IVectorConvolver.IntrinsicImpl => Sse.IsSupported ? Convolver<#= t.name #>Intrinsic.Instance : (IConvolver)this;
	}
<#
}
#>
}
#endif
<#+
class procDef
{
	public string name;
	public int channels;
	public int colors;
	public int xUnroll;
	public int yUnroll;
}
#>